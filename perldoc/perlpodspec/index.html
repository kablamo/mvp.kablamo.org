<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta content="width=device-width, initial-scale=1" name="viewport">
        <link href="/theme/css/normalize.css" rel="stylesheet">
        <!--<link rel="stylesheet" href="/theme/css/skeleton.css" />-->
        <link href="/theme/css/statocles-default.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <script crossorigin="anonymous" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" src="http://code.jquery.com/jquery-3.2.1.min.js"></script>
        <title>perlpodspec - Minimum Viable Perl</title>
        <meta content="Statocles 0.086" name="generator">
        
        <script>
            $( document ).ready(function() {
                $('.sub-menu ul').hide();
                $('.sub-menu.perldoc ul').show();
                $('.sub-menu.perldoc div').toggleClass("fa-caret-up fa-caret-down");
                $(".sub-menu a").click(function () {
                    $(this).parent(".sub-menu").siblings().children('ul').hide();
                    $(this).parent(".sub-menu").children("ul").slideToggle("100");
                    $(this).find(".right").toggleClass("fa-caret-up fa-caret-down");
                });
            });
        </script>
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-110455056-1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'UA-110455056-1');
        </script>
    </head>
    <body>
        <header>
        </header>
        <div class="container">

                <div class="left column full-height">
                    <div class="sidebar">
                    
<a class="home" href="/">Minimum<br>Viable<br>Perl</a><br><br><br>

<div class="animated bounceInDown">
  <ul>
    <li class="basics sub-menu">
      <a href="/perldoc/perlpodspec/#basics">The basics<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/basics/hello">Hello world</a></li>
        <li><a href="/basics/variables">Variables</a></li>
        <li><a href="/basics/references">References</a></li>
        <li><a href="/basics/functions">Functions</a></li>
        <li><a href="/basics/flow">Conditionals</a></li>
        <li><a href="/basics/loops">Loops</a></li>
        <li><a href="/basics/exceptions">Exceptions</a></li>
        <li><a href="/basics/regexps">Regexps</a></li>
        <li><a href="/basics/files">Files</a></li>
      </ul>
    </li>
    <li class="oo sub-menu">
      <a href="/perldoc/perlpodspec/#oo">Object oriented programming<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/oo/story">The (weird) story of Perl OO</a></li>
        <li><a href="/oo/classes">Classes</a></li>
        <li><a href="/oo/attributes">Attributes</a></li>
        <li><a href="/oo/modifiers">Method modifiers</a></li>
        <li><a href="/oo/roles">Roles</a></li>
        <li><a href="/oo/inheritance">Inheritance</a></li>
      </ul>
    </li>
    <li class="debugging sub-menu">
      <a href="/perldoc/perlpodspec/#basics">Debugging<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/debugging/data-printer">Examining data structures</a></li>
        <li><a href="/debugging/stack-trace">Forcing stack traces</a></li>
      </ul>
    </li>
    <li class="dependencies sub-menu">
      <a href="/perldoc/perlpodspec/#dependencies">Perl libraries<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/dependencies/perl5lib">Loading libraries from custom locations</a></li>
        <li><a href="/dependencies/cpanm">Installing libraries with cpanm</a></li>
        <li><a href="/dependencies/metacpan">Choosing libraries from MetaCPAN</a></li>
        <li><a href="/dependencies/carton">Managing project dependencies with Carton</a></li>
        <li><a href="/dependencies/pmtools">What version is installed and where?</a></li>
      </ul>
    </li>
    <li class="testing sub-menu">
      <a href="/perldoc/perlpodspec/#testing">Testing<div class="fa fa-caret-down right"></div></a>
      <ul>
        <li><a href="/testing/intro">Introduction to testing</a></li>
        <li><a href="/testing/warnings">Testing warnings and exceptions</a></li>
        <li><a href="/testing/data">Testing data structures</a></li>
        <li><a href="/testing/mock">Testing with mock objects</a></li>
        <li><a href="/testing/libs">Build your own test libraries</a></li>
      </ul>
    </li>
    <li><a href="/perl">Perl design goals</a></li>
    <li><a href="/see-also">Book recommendations</a></li>
    <li><a href="/about">About this book</a></li>
  </ul>
</div>

                    
                    
                    </div>
                </div>

                <div class="right column">
                    <main>
                    <div class="crumbtrail">
<ul>
    <li>
        <a href="/perldoc/perlpodspec/">perlpodspec</a>
    </li>
</ul>
(<a href="/perldoc/perlpodspec/source.html">source</a>)
</div>
<h1 id="NAME">NAME</h1>

<p>perlpodspec - Plain Old Documentation: format specification and notes</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This document is detailed notes on the Pod markup language. Most people will only have to read <a href="/perldoc/perlpod/">perlpod</a> to know how to write in Pod, but this document may answer some incidental questions to do with parsing and rendering Pod.</p>

<p>In this document, &quot;must&quot; / &quot;must not&quot;, &quot;should&quot; / &quot;should not&quot;, and &quot;may&quot; have their conventional (cf. RFC 2119) meanings: &quot;X must do Y&quot; means that if X doesn&#39;t do Y, it&#39;s against this specification, and should really be fixed. &quot;X should do Y&quot; means that it&#39;s recommended, but X may fail to do Y, if there&#39;s a good reason. &quot;X may do Y&quot; is merely a note that X can do Y at will (although it is up to the reader to detect any connotation of &quot;and I think it would be <i>nice</i> if X did Y&quot; versus &quot;it wouldn&#39;t really <i>bother</i> me if X did Y&quot;).</p>

<p>Notably, when I say &quot;the parser should do Y&quot;, the parser may fail to do Y, if the calling application explicitly requests that the parser <i>not</i> do Y. I often phrase this as &quot;the parser should, by default, do Y.&quot; This doesn&#39;t <i>require</i> the parser to provide an option for turning off whatever feature Y is (like expanding tabs in verbatim paragraphs), although it implicates that such an option <i>may</i> be provided.</p>

<h1 id="Pod-Definitions">Pod Definitions</h1>

<p>Pod is embedded in files, typically Perl source files, although you can write a file that&#39;s nothing but Pod.</p>

<p>A <b>line</b> in a file consists of zero or more non-newline characters, terminated by either a newline or the end of the file.</p>

<p>A <b>newline sequence</b> is usually a platform-dependent concept, but Pod parsers should understand it to mean any of CR (ASCII 13), LF (ASCII 10), or a CRLF (ASCII 13 followed immediately by ASCII 10), in addition to any other system-specific meaning. The first CR/CRLF/LF sequence in the file may be used as the basis for identifying the newline sequence for parsing the rest of the file.</p>

<p>A <b>blank line</b> is a line consisting entirely of zero or more spaces (ASCII 32) or tabs (ASCII 9), and terminated by a newline or end-of-file. A <b>non-blank line</b> is a line containing one or more characters other than space or tab (and terminated by a newline or end-of-file).</p>

<p>(<i>Note:</i> Many older Pod parsers did not accept a line consisting of spaces/tabs and then a newline as a blank line. The only lines they considered blank were lines consisting of <i>no characters at all</i>, terminated by a newline.)</p>

<p><b>Whitespace</b> is used in this document as a blanket term for spaces, tabs, and newline sequences. (By itself, this term usually refers to literal whitespace. That is, sequences of whitespace characters in Pod source, as opposed to &quot;E&lt;32&gt;&quot;, which is a formatting code that <i>denotes</i> a whitespace character.)</p>

<p>A <b>Pod parser</b> is a module meant for parsing Pod (regardless of whether this involves calling callbacks or building a parse tree or directly formatting it). A <b>Pod formatter</b> (or <b>Pod translator</b>) is a module or program that converts Pod to some other format (HTML, plaintext, TeX, PostScript, RTF). A <b>Pod processor</b> might be a formatter or translator, or might be a program that does something else with the Pod (like counting words, scanning for index points, etc.).</p>

<p>Pod content is contained in <b>Pod blocks</b>. A Pod block starts with a line that matches <code>m/\A=[a-zA-Z]/</code>, and continues up to the next line that matches <code>m/\A=cut/</code> or up to the end of the file if there is no <code>m/\A=cut/</code> line.</p>

<p>Within a Pod block, there are <b>Pod paragraphs</b>. A Pod paragraph consists of non-blank lines of text, separated by one or more blank lines.</p>

<p>For purposes of Pod processing, there are four types of paragraphs in a Pod block:</p>

<ul>

<li><p>A command paragraph (also called a &quot;directive&quot;). The first line of this paragraph must match <code>m/\A=[a-zA-Z]/</code>. Command paragraphs are typically one line, as in:</p>

<pre><code>  =head1 NOTES

  =item *</code></pre>

<p>But they may span several (non-blank) lines:</p>

<pre><code>  =for comment
  Hm, I wonder what it would look like if
  you tried to write a BNF for Pod from this.

  =head3 Dr. Strangelove, or: How I Learned to
  Stop Worrying and Love the Bomb</code></pre>

<p><i>Some</i> command paragraphs allow formatting codes in their content (i.e., after the part that matches <code>m/\A=[a-zA-Z]\S*\s*/</code>), as in:</p>

<pre><code>  =head1 Did You Remember to C&lt;use strict;&gt;?</code></pre>

<p>In other words, the Pod processing handler for &quot;head1&quot; will apply the same processing to &quot;Did You Remember to C&lt;use strict;&gt;?&quot; that it would to an ordinary paragraph (i.e., formatting codes like &quot;C&lt;...&gt;&quot;) are parsed and presumably formatted appropriately, and whitespace in the form of literal spaces and/or tabs is not significant.</p>

</li>
<li><p>A <b>verbatim paragraph</b>. The first line of this paragraph must be a literal space or tab, and this paragraph must not be inside a &quot;=begin <i>identifier</i>&quot;, ... &quot;=end <i>identifier</i>&quot; sequence unless &quot;<i>identifier</i>&quot; begins with a colon (&quot;:&quot;). That is, if a paragraph starts with a literal space or tab, but <i>is</i> inside a &quot;=begin <i>identifier</i>&quot;, ... &quot;=end <i>identifier</i>&quot; region, then it&#39;s a data paragraph, unless &quot;<i>identifier</i>&quot; begins with a colon.</p>

<p>Whitespace <i>is</i> significant in verbatim paragraphs (although, in processing, tabs are probably expanded).</p>

</li>
<li><p>An <b>ordinary paragraph</b>. A paragraph is an ordinary paragraph if its first line matches neither <code>m/\A=[a-zA-Z]/</code> nor <code>m/\A[ \t]/</code>, <i>and</i> if it&#39;s not inside a &quot;=begin <i>identifier</i>&quot;, ... &quot;=end <i>identifier</i>&quot; sequence unless &quot;<i>identifier</i>&quot; begins with a colon (&quot;:&quot;).</p>

</li>
<li><p>A <b>data paragraph</b>. This is a paragraph that <i>is</i> inside a &quot;=begin <i>identifier</i>&quot; ... &quot;=end <i>identifier</i>&quot; sequence where &quot;<i>identifier</i>&quot; does <i>not</i> begin with a literal colon (&quot;:&quot;). In some sense, a data paragraph is not part of Pod at all (i.e., effectively it&#39;s &quot;out-of-band&quot;), since it&#39;s not subject to most kinds of Pod parsing; but it is specified here, since Pod parsers need to be able to call an event for it, or store it in some form in a parse tree, or at least just parse <i>around</i> it.</p>

</li>
</ul>

<p>For example: consider the following paragraphs:</p>

<pre><code>  # &lt;- that&#39;s the 0th column

  =head1 Foo

  Stuff

    $foo-&gt;bar

  =cut</code></pre>

<p>Here, &quot;=head1 Foo&quot; and &quot;=cut&quot; are command paragraphs because the first line of each matches <code>m/\A=[a-zA-Z]/</code>. &quot;<i>[space][space]</i>$foo-&gt;bar&quot; is a verbatim paragraph, because its first line starts with a literal whitespace character (and there&#39;s no &quot;=begin&quot;...&quot;=end&quot; region around).</p>

<p>The &quot;=begin <i>identifier</i>&quot; ... &quot;=end <i>identifier</i>&quot; commands stop paragraphs that they surround from being parsed as ordinary or verbatim paragraphs, if <i>identifier</i> doesn&#39;t begin with a colon. This is discussed in detail in the section <a href="#About-Data-Paragraphs-and-begin-end-Regions">&quot;About Data Paragraphs and &quot;=begin/=end&quot; Regions&quot;</a>.</p>

<h1 id="Pod-Commands">Pod Commands</h1>

<p>This section is intended to supplement and clarify the discussion in <a href="/perldoc/perlpod/#Command-Paragraph">&quot;Command Paragraph&quot; in perlpod</a>. These are the currently recognized Pod commands:</p>

<dl>

<dt>&quot;=head1&quot;, &quot;=head2&quot;, &quot;=head3&quot;, &quot;=head4&quot;</dt>
<dd>

<p>This command indicates that the text in the remainder of the paragraph is a heading. That text may contain formatting codes. Examples:</p>

<pre><code>  =head1 Object Attributes

  =head3 What B&lt;Not&gt; to Do!</code></pre>

</dd>
<dt>&quot;=pod&quot;</dt>
<dd>

<p>This command indicates that this paragraph begins a Pod block. (If we are already in the middle of a Pod block, this command has no effect at all.) If there is any text in this command paragraph after &quot;=pod&quot;, it must be ignored. Examples:</p>

<pre><code>  =pod

  This is a plain Pod paragraph.

  =pod This text is ignored.</code></pre>

</dd>
<dt>&quot;=cut&quot;</dt>
<dd>

<p>This command indicates that this line is the end of this previously started Pod block. If there is any text after &quot;=cut&quot; on the line, it must be ignored. Examples:</p>

<pre><code>  =cut

  =cut The documentation ends here.

  =cut
  # This is the first line of program text.
  sub foo { # This is the second.</code></pre>

<p>It is an error to try to <i>start</i> a Pod block with a &quot;=cut&quot; command. In that case, the Pod processor must halt parsing of the input file, and must by default emit a warning.</p>

</dd>
<dt>&quot;=over&quot;</dt>
<dd>

<p>This command indicates that this is the start of a list/indent region. If there is any text following the &quot;=over&quot;, it must consist of only a nonzero positive numeral. The semantics of this numeral is explained in the <a href="#About-over...-back-Regions">&quot;About =over...=back Regions&quot;</a> section, further below. Formatting codes are not expanded. Examples:</p>

<pre><code>  =over 3

  =over 3.5

  =over</code></pre>

</dd>
<dt>&quot;=item&quot;</dt>
<dd>

<p>This command indicates that an item in a list begins here. Formatting codes are processed. The semantics of the (optional) text in the remainder of this paragraph are explained in the <a href="#About-over...-back-Regions">&quot;About =over...=back Regions&quot;</a> section, further below. Examples:</p>

<pre><code>  =item

  =item *

  =item      *    

  =item 14

  =item   3.

  =item C&lt;&lt; $thing-&gt;stuff(I&lt;dodad&gt;) &gt;&gt;

  =item For transporting us beyond seas to be tried for pretended
  offenses

  =item He is at this time transporting large armies of foreign
  mercenaries to complete the works of death, desolation and
  tyranny, already begun with circumstances of cruelty and perfidy
  scarcely paralleled in the most barbarous ages, and totally
  unworthy the head of a civilized nation.</code></pre>

</dd>
<dt>&quot;=back&quot;</dt>
<dd>

<p>This command indicates that this is the end of the region begun by the most recent &quot;=over&quot; command. It permits no text after the &quot;=back&quot; command.</p>

</dd>
<dt>&quot;=begin formatname&quot;</dt>
<dd>

</dd>
<dt>&quot;=begin formatname parameter&quot;</dt>
<dd>

<p>This marks the following paragraphs (until the matching &quot;=end formatname&quot;) as being for some special kind of processing. Unless &quot;formatname&quot; begins with a colon, the contained non-command paragraphs are data paragraphs. But if &quot;formatname&quot; <i>does</i> begin with a colon, then non-command paragraphs are ordinary paragraphs or data paragraphs. This is discussed in detail in the section <a href="#About-Data-Paragraphs-and-begin-end-Regions">&quot;About Data Paragraphs and &quot;=begin/=end&quot; Regions&quot;</a>.</p>

<p>It is advised that formatnames match the regexp <code>m/\A:?[-a-zA-Z0-9_]+\z/</code>. Everything following whitespace after the formatname is a parameter that may be used by the formatter when dealing with this region. This parameter must not be repeated in the &quot;=end&quot; paragraph. Implementors should anticipate future expansion in the semantics and syntax of the first parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</p>

</dd>
<dt>&quot;=end formatname&quot;</dt>
<dd>

<p>This marks the end of the region opened by the matching &quot;=begin formatname&quot; region. If &quot;formatname&quot; is not the formatname of the most recent open &quot;=begin formatname&quot; region, then this is an error, and must generate an error message. This is discussed in detail in the section <a href="#About-Data-Paragraphs-and-begin-end-Regions">&quot;About Data Paragraphs and &quot;=begin/=end&quot; Regions&quot;</a>.</p>

</dd>
<dt>&quot;=for formatname text...&quot;</dt>
<dd>

<p>This is synonymous with:</p>

<pre><code>     =begin formatname

     text...

     =end formatname</code></pre>

<p>That is, it creates a region consisting of a single paragraph; that paragraph is to be treated as a normal paragraph if &quot;formatname&quot; begins with a &quot;:&quot;; if &quot;formatname&quot; <i>doesn&#39;t</i> begin with a colon, then &quot;text...&quot; will constitute a data paragraph. There is no way to use &quot;=for formatname text...&quot; to express &quot;text...&quot; as a verbatim paragraph.</p>

</dd>
<dt>&quot;=encoding encodingname&quot;</dt>
<dd>

<p>This command, which should occur early in the document (at least before any non-US-ASCII data!), declares that this document is encoded in the encoding <i>encodingname</i>, which must be an encoding name that <a href="https://metacpan.org/pod/Encode" rel="external">Encode</a> recognizes. (Encode&#39;s list of supported encodings, in <a href="https://metacpan.org/pod/Encode::Supported" rel="external">Encode::Supported</a>, is useful here.) If the Pod parser cannot decode the declared encoding, it should emit a warning and may abort parsing the document altogether.</p>

<p>A document having more than one &quot;=encoding&quot; line should be considered an error. Pod processors may silently tolerate this if the not-first &quot;=encoding&quot; lines are just duplicates of the first one (e.g., if there&#39;s a &quot;=encoding utf8&quot; line, and later on another &quot;=encoding utf8&quot; line). But Pod processors should complain if there are contradictory &quot;=encoding&quot; lines in the same document (e.g., if there is a &quot;=encoding utf8&quot; early in the document and &quot;=encoding big5&quot; later). Pod processors that recognize BOMs may also complain if they see an &quot;=encoding&quot; line that contradicts the BOM (e.g., if a document with a UTF-16LE BOM has an &quot;=encoding shiftjis&quot; line).</p>

</dd>
</dl>

<p>If a Pod processor sees any command other than the ones listed above (like &quot;=head&quot;, or &quot;=haed1&quot;, or &quot;=stuff&quot;, or &quot;=cuttlefish&quot;, or &quot;=w123&quot;), that processor must by default treat this as an error. It must not process the paragraph beginning with that command, must by default warn of this as an error, and may abort the parse. A Pod parser may allow a way for particular applications to add to the above list of known commands, and to stipulate, for each additional command, whether formatting codes should be processed.</p>

<p>Future versions of this specification may add additional commands.</p>

<h1 id="Pod-Formatting-Codes">Pod Formatting Codes</h1>

<p>(Note that in previous drafts of this document and of perlpod, formatting codes were referred to as &quot;interior sequences&quot;, and this term may still be found in the documentation for Pod parsers, and in error messages from Pod processors.)</p>

<p>There are two syntaxes for formatting codes:</p>

<ul>

<li><p>A formatting code starts with a capital letter (just US-ASCII [A-Z]) followed by a &quot;&lt;&quot;, any number of characters, and ending with the first matching &quot;&gt;&quot;. Examples:</p>

<pre><code>    That&#39;s what I&lt;you&gt; think!

    What&#39;s C&lt;dump()&gt; for?

    X&lt;C&lt;chmod&gt; and C&lt;unlink()&gt; Under Different Operating Systems&gt;</code></pre>

</li>
<li><p>A formatting code starts with a capital letter (just US-ASCII [A-Z]) followed by two or more &quot;&lt;&quot;&#39;s, one or more whitespace characters, any number of characters, one or more whitespace characters, and ending with the first matching sequence of two or more &quot;&gt;&quot;&#39;s, where the number of &quot;&gt;&quot;&#39;s equals the number of &quot;&lt;&quot;&#39;s in the opening of this formatting code. Examples:</p>

<pre><code>    That&#39;s what I&lt;&lt; you &gt;&gt; think!

    C&lt;&lt;&lt; open(X, &quot;&gt;&gt;thing.dat&quot;) || die $! &gt;&gt;&gt;

    B&lt;&lt; $foo-&gt;bar(); &gt;&gt;</code></pre>

<p>With this syntax, the whitespace character(s) after the &quot;C&lt;&lt;&lt;&quot; and before the &quot;&gt;&gt;&gt;&quot; (or whatever letter) are <i>not</i> renderable. They do not signify whitespace, are merely part of the formatting codes themselves. That is, these are all synonymous:</p>

<pre><code>    C&lt;thing&gt;
    C&lt;&lt; thing &gt;&gt;
    C&lt;&lt;           thing     &gt;&gt;
    C&lt;&lt;&lt;   thing &gt;&gt;&gt;
    C&lt;&lt;&lt;&lt;
    thing
               &gt;&gt;&gt;&gt;</code></pre>

<p>and so on.</p>

<p>Finally, the multiple-angle-bracket form does <i>not</i> alter the interpretation of nested formatting codes, meaning that the following four example lines are identical in meaning:</p>

<pre><code>  B&lt;example: C&lt;$a E&lt;lt&gt;=E&lt;gt&gt; $b&gt;&gt;

  B&lt;example: C&lt;&lt; $a &lt;=&gt; $b &gt;&gt;&gt;

  B&lt;example: C&lt;&lt; $a E&lt;lt&gt;=E&lt;gt&gt; $b &gt;&gt;&gt;

  B&lt;&lt;&lt; example: C&lt;&lt; $a E&lt;lt&gt;=E&lt;gt&gt; $b &gt;&gt; &gt;&gt;&gt;</code></pre>

</li>
</ul>

<p>In parsing Pod, a notably tricky part is the correct parsing of (potentially nested!) formatting codes. Implementors should consult the code in the <code>parse_text</code> routine in Pod::Parser as an example of a correct implementation.</p>

<dl>

<dt><code>I&lt;text&gt;</code> -- italic text</dt>
<dd>

<p>See the brief discussion in <a href="/perldoc/perlpod/#Formatting-Codes">&quot;Formatting Codes&quot; in perlpod</a>.</p>

</dd>
<dt><code>B&lt;text&gt;</code> -- bold text</dt>
<dd>

<p>See the brief discussion in <a href="/perldoc/perlpod/#Formatting-Codes">&quot;Formatting Codes&quot; in perlpod</a>.</p>

</dd>
<dt><code>C&lt;code&gt;</code> -- code text</dt>
<dd>

<p>See the brief discussion in <a href="/perldoc/perlpod/#Formatting-Codes">&quot;Formatting Codes&quot; in perlpod</a>.</p>

</dd>
<dt><code>F&lt;filename&gt;</code> -- style for filenames</dt>
<dd>

<p>See the brief discussion in <a href="/perldoc/perlpod/#Formatting-Codes">&quot;Formatting Codes&quot; in perlpod</a>.</p>

</dd>
<dt><code>X&lt;topic name&gt;</code> -- an index entry</dt>
<dd>

<p>See the brief discussion in <a href="/perldoc/perlpod/#Formatting-Codes">&quot;Formatting Codes&quot; in perlpod</a>.</p>

<p>This code is unusual in that most formatters completely discard this code and its content. Other formatters will render it with invisible codes that can be used in building an index of the current document.</p>

</dd>
<dt><code>Z&lt;&gt;</code> -- a null (zero-effect) formatting code</dt>
<dd>

<p>Discussed briefly in <a href="/perldoc/perlpod/#Formatting-Codes">&quot;Formatting Codes&quot; in perlpod</a>.</p>

<p>This code is unusual in that it should have no content. That is, a processor may complain if it sees <code>Z&lt;potatoes&gt;</code>. Whether or not it complains, the <i>potatoes</i> text should ignored.</p>

</dd>
<dt><code>L&lt;name&gt;</code> -- a hyperlink</dt>
<dd>

<p>The complicated syntaxes of this code are discussed at length in <a href="/perldoc/perlpod/#Formatting-Codes">&quot;Formatting Codes&quot; in perlpod</a>, and implementation details are discussed below, in <a href="#About-L...-Codes">&quot;About L&lt;...&gt; Codes&quot;</a>. Parsing the contents of L&lt;content&gt; is tricky. Notably, the content has to be checked for whether it looks like a URL, or whether it has to be split on literal &quot;|&quot; and/or &quot;/&quot; (in the right order!), and so on, <i>before</i> E&lt;...&gt; codes are resolved.</p>

</dd>
<dt><code>E&lt;escape&gt;</code> -- a character escape</dt>
<dd>

<p>See <a href="/perldoc/perlpod/#Formatting-Codes">&quot;Formatting Codes&quot; in perlpod</a>, and several points in <a href="#Notes-on-Implementing-Pod-Processors">&quot;Notes on Implementing Pod Processors&quot;</a>.</p>

</dd>
<dt><code>S&lt;text&gt;</code> -- text contains non-breaking spaces</dt>
<dd>

<p>This formatting code is syntactically simple, but semantically complex. What it means is that each space in the printable content of this code signifies a non-breaking space.</p>

<p>Consider:</p>

<pre><code>    C&lt;$x ? $y    :  $z&gt;

    S&lt;C&lt;$x ? $y     :  $z&gt;&gt;</code></pre>

<p>Both signify the monospace (c[ode] style) text consisting of &quot;$x&quot;, one space, &quot;?&quot;, one space, &quot;:&quot;, one space, &quot;$z&quot;. The difference is that in the latter, with the S code, those spaces are not &quot;normal&quot; spaces, but instead are non-breaking spaces.</p>

</dd>
</dl>

<p>If a Pod processor sees any formatting code other than the ones listed above (as in &quot;N&lt;...&gt;&quot;, or &quot;Q&lt;...&gt;&quot;, etc.), that processor must by default treat this as an error. A Pod parser may allow a way for particular applications to add to the above list of known formatting codes; a Pod parser might even allow a way to stipulate, for each additional command, whether it requires some form of special processing, as L&lt;...&gt; does.</p>

<p>Future versions of this specification may add additional formatting codes.</p>

<p>Historical note: A few older Pod processors would not see a &quot;&gt;&quot; as closing a &quot;C&lt;&quot; code, if the &quot;&gt;&quot; was immediately preceded by a &quot;-&quot;. This was so that this:</p>

<pre><code>    C&lt;$foo-&gt;bar&gt;</code></pre>

<p>would parse as equivalent to this:</p>

<pre><code>    C&lt;$foo-E&lt;gt&gt;bar&gt;</code></pre>

<p>instead of as equivalent to a &quot;C&quot; formatting code containing only &quot;$foo-&quot;, and then a &quot;bar&gt;&quot; outside the &quot;C&quot; formatting code. This problem has since been solved by the addition of syntaxes like this:</p>

<pre><code>    C&lt;&lt; $foo-&gt;bar &gt;&gt;</code></pre>

<p>Compliant parsers must not treat &quot;-&gt;&quot; as special.</p>

<p>Formatting codes absolutely cannot span paragraphs. If a code is opened in one paragraph, and no closing code is found by the end of that paragraph, the Pod parser must close that formatting code, and should complain (as in &quot;Unterminated I code in the paragraph starting at line 123: &#39;Time objects are not...&#39;&quot;). So these two paragraphs:</p>

<pre><code>  I&lt;I told you not to do this!

  Don&#39;t make me say it again!&gt;</code></pre>

<p>...must <i>not</i> be parsed as two paragraphs in italics (with the I code starting in one paragraph and starting in another.) Instead, the first paragraph should generate a warning, but that aside, the above code must parse as if it were:</p>

<pre><code>  I&lt;I told you not to do this!&gt;

  Don&#39;t make me say it again!E&lt;gt&gt;</code></pre>

<p>(In SGMLish jargon, all Pod commands are like block-level elements, whereas all Pod formatting codes are like inline-level elements.)</p>

<h1 id="Notes-on-Implementing-Pod-Processors">Notes on Implementing Pod Processors</h1>

<p>The following is a long section of miscellaneous requirements and suggestions to do with Pod processing.</p>

<ul>

<li><p>Pod formatters should tolerate lines in verbatim blocks that are of any length, even if that means having to break them (possibly several times, for very long lines) to avoid text running off the side of the page. Pod formatters may warn of such line-breaking. Such warnings are particularly appropriate for lines are over 100 characters long, which are usually not intentional.</p>

</li>
<li><p>Pod parsers must recognize <i>all</i> of the three well-known newline formats: CR, LF, and CRLF. See <a href="/perldoc/perlport/">perlport</a>.</p>

</li>
<li><p>Pod parsers should accept input lines that are of any length.</p>

</li>
<li><p>Since Perl recognizes a Unicode Byte Order Mark at the start of files as signaling that the file is Unicode encoded as in UTF-16 (whether big-endian or little-endian) or UTF-8, Pod parsers should do the same. Otherwise, the character encoding should be understood as being UTF-8 if the first highbit byte sequence in the file seems valid as a UTF-8 sequence, or otherwise as CP-1252 (earlier versions of this specification used Latin-1 instead of CP-1252).</p>

<p>Future versions of this specification may specify how Pod can accept other encodings. Presumably treatment of other encodings in Pod parsing would be as in XML parsing: whatever the encoding declared by a particular Pod file, content is to be stored in memory as Unicode characters.</p>

</li>
<li><p>The well known Unicode Byte Order Marks are as follows: if the file begins with the two literal byte values 0xFE 0xFF, this is the BOM for big-endian UTF-16. If the file begins with the two literal byte value 0xFF 0xFE, this is the BOM for little-endian UTF-16. On an ASCII platform, if the file begins with the three literal byte values 0xEF 0xBB 0xBF, this is the BOM for UTF-8. A mechanism portable to EBCDIC platforms is to:</p>

<pre><code>  my $utf8_bom = &quot;\x{FEFF}&quot;;
  utf8::encode($utf8_bom);</code></pre>

</li>
<li><p>A naive, but often sufficient heuristic on ASCII platforms, for testing the first highbit byte-sequence in a BOM-less file (whether in code or in Pod!), to see whether that sequence is valid as UTF-8 (RFC 2279) is to check whether that the first byte in the sequence is in the range 0xC2 - 0xFD <i>and</i> whether the next byte is in the range 0x80 - 0xBF. If so, the parser may conclude that this file is in UTF-8, and all highbit sequences in the file should be assumed to be UTF-8. Otherwise the parser should treat the file as being in CP-1252. (A better check, and which works on EBCDIC platforms as well, is to pass a copy of the sequence to <a href="https://metacpan.org/pod/utf8" rel="external">utf8::decode()</a> which performs a full validity check on the sequence and returns TRUE if it is valid UTF-8, FALSE otherwise. This function is always pre-loaded, is fast because it is written in C, and will only get called at most once, so you don&#39;t need to avoid it out of performance concerns.) In the unlikely circumstance that the first highbit sequence in a truly non-UTF-8 file happens to appear to be UTF-8, one can cater to our heuristic (as well as any more intelligent heuristic) by prefacing that line with a comment line containing a highbit sequence that is clearly <i>not</i> valid as UTF-8. A line consisting of simply &quot;#&quot;, an e-acute, and any non-highbit byte, is sufficient to establish this file&#39;s encoding.</p>

</li>
<li><p>Pod processors must treat a &quot;=for [label] [content...]&quot; paragraph as meaning the same thing as a &quot;=begin [label]&quot; paragraph, content, and an &quot;=end [label]&quot; paragraph. (The parser may conflate these two constructs, or may leave them distinct, in the expectation that the formatter will nevertheless treat them the same.)</p>

</li>
<li><p>When rendering Pod to a format that allows comments (i.e., to nearly any format other than plaintext), a Pod formatter must insert comment text identifying its name and version number, and the name and version numbers of any modules it might be using to process the Pod. Minimal examples:</p>

<pre><code> %% POD::Pod2PS v3.14159, using POD::Parser v1.92

 &lt;!-- Pod::HTML v3.14159, using POD::Parser v1.92 --&gt;

 {\doccomm generated by Pod::Tree::RTF 3.14159 using Pod::Tree 1.08}

 .\&quot; Pod::Man version 3.14159, using POD::Parser version 1.92</code></pre>

<p>Formatters may also insert additional comments, including: the release date of the Pod formatter program, the contact address for the author(s) of the formatter, the current time, the name of input file, the formatting options in effect, version of Perl used, etc.</p>

<p>Formatters may also choose to note errors/warnings as comments, besides or instead of emitting them otherwise (as in messages to STDERR, or <code>die</code>ing).</p>

</li>
<li><p>Pod parsers <i>may</i> emit warnings or error messages (&quot;Unknown E code E&lt;zslig&gt;!&quot;) to STDERR (whether through printing to STDERR, or <code>warn</code>ing/<code>carp</code>ing, or <code>die</code>ing/<code>croak</code>ing), but <i>must</i> allow suppressing all such STDERR output, and instead allow an option for reporting errors/warnings in some other way, whether by triggering a callback, or noting errors in some attribute of the document object, or some similarly unobtrusive mechanism -- or even by appending a &quot;Pod Errors&quot; section to the end of the parsed form of the document.</p>

</li>
<li><p>In cases of exceptionally aberrant documents, Pod parsers may abort the parse. Even then, using <code>die</code>ing/<code>croak</code>ing is to be avoided; where possible, the parser library may simply close the input file and add text like &quot;*** Formatting Aborted ***&quot; to the end of the (partial) in-memory document.</p>

</li>
<li><p>In paragraphs where formatting codes (like E&lt;...&gt;, B&lt;...&gt;) are understood (i.e., <i>not</i> verbatim paragraphs, but <i>including</i> ordinary paragraphs, and command paragraphs that produce renderable text, like &quot;=head1&quot;), literal whitespace should generally be considered &quot;insignificant&quot;, in that one literal space has the same meaning as any (nonzero) number of literal spaces, literal newlines, and literal tabs (as long as this produces no blank lines, since those would terminate the paragraph). Pod parsers should compact literal whitespace in each processed paragraph, but may provide an option for overriding this (since some processing tasks do not require it), or may follow additional special rules (for example, specially treating period-space-space or period-newline sequences).</p>

</li>
<li><p>Pod parsers should not, by default, try to coerce apostrophe (&#39;) and quote (&quot;) into smart quotes (little 9&#39;s, 66&#39;s, 99&#39;s, etc), nor try to turn backtick (`) into anything else but a single backtick character (distinct from an open quote character!), nor &quot;--&quot; into anything but two minus signs. They <i>must never</i> do any of those things to text in C&lt;...&gt; formatting codes, and never <i>ever</i> to text in verbatim paragraphs.</p>

</li>
<li><p>When rendering Pod to a format that has two kinds of hyphens (-), one that&#39;s a non-breaking hyphen, and another that&#39;s a breakable hyphen (as in &quot;object-oriented&quot;, which can be split across lines as &quot;object-&quot;, newline, &quot;oriented&quot;), formatters are encouraged to generally translate &quot;-&quot; to non-breaking hyphen, but may apply heuristics to convert some of these to breaking hyphens.</p>

</li>
<li><p>Pod formatters should make reasonable efforts to keep words of Perl code from being broken across lines. For example, &quot;Foo::Bar&quot; in some formatting systems is seen as eligible for being broken across lines as &quot;Foo::&quot; newline &quot;Bar&quot; or even &quot;Foo::-&quot; newline &quot;Bar&quot;. This should be avoided where possible, either by disabling all line-breaking in mid-word, or by wrapping particular words with internal punctuation in &quot;don&#39;t break this across lines&quot; codes (which in some formats may not be a single code, but might be a matter of inserting non-breaking zero-width spaces between every pair of characters in a word.)</p>

</li>
<li><p>Pod parsers should, by default, expand tabs in verbatim paragraphs as they are processed, before passing them to the formatter or other processor. Parsers may also allow an option for overriding this.</p>

</li>
<li><p>Pod parsers should, by default, remove newlines from the end of ordinary and verbatim paragraphs before passing them to the formatter. For example, while the paragraph you&#39;re reading now could be considered, in Pod source, to end with (and contain) the newline(s) that end it, it should be processed as ending with (and containing) the period character that ends this sentence.</p>

</li>
<li><p>Pod parsers, when reporting errors, should make some effort to report an approximate line number (&quot;Nested E&lt;&gt;&#39;s in Paragraph #52, near line 633 of Thing/Foo.pm!&quot;), instead of merely noting the paragraph number (&quot;Nested E&lt;&gt;&#39;s in Paragraph #52 of Thing/Foo.pm!&quot;). Where this is problematic, the paragraph number should at least be accompanied by an excerpt from the paragraph (&quot;Nested E&lt;&gt;&#39;s in Paragraph #52 of Thing/Foo.pm, which begins &#39;Read/write accessor for the C&lt;interest rate&gt; attribute...&#39;&quot;).</p>

</li>
<li><p>Pod parsers, when processing a series of verbatim paragraphs one after another, should consider them to be one large verbatim paragraph that happens to contain blank lines. I.e., these two lines, which have a blank line between them:</p>

<pre><code>        use Foo;

        print Foo-&gt;VERSION</code></pre>

<p>should be unified into one paragraph (&quot;\tuse Foo;\n\n\tprint Foo-&gt;VERSION&quot;) before being passed to the formatter or other processor. Parsers may also allow an option for overriding this.</p>

<p>While this might be too cumbersome to implement in event-based Pod parsers, it is straightforward for parsers that return parse trees.</p>

</li>
<li><p>Pod formatters, where feasible, are advised to avoid splitting short verbatim paragraphs (under twelve lines, say) across pages.</p>

</li>
<li><p>Pod parsers must treat a line with only spaces and/or tabs on it as a &quot;blank line&quot; such as separates paragraphs. (Some older parsers recognized only two adjacent newlines as a &quot;blank line&quot; but would not recognize a newline, a space, and a newline, as a blank line. This is noncompliant behavior.)</p>

</li>
<li><p>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Simple, comes with modern versions of Perl.</p>

</li>
<li><p>Characters in Pod documents may be conveyed either as literals, or by number in E&lt;n&gt; codes, or by an equivalent mnemonic, as in E&lt;eacute&gt; which is exactly equivalent to E&lt;233&gt;. The numbers are the Latin1/Unicode values, even on EBCDIC platforms.</p>

<p>When referring to characters by using a E&lt;n&gt; numeric code, numbers in the range 32-126 refer to those well known US-ASCII characters (also defined there by Unicode, with the same meaning), which all Pod formatters must render faithfully. Characters whose E&lt;&gt; numbers are in the ranges 0-31 and 127-159 should not be used (neither as literals, nor as E&lt;number&gt; codes), except for the literal byte-sequences for newline (ASCII 13, ASCII 13 10, or ASCII 10), and tab (ASCII 9).</p>

<p>Numbers in the range 160-255 refer to Latin-1 characters (also defined there by Unicode, with the same meaning). Numbers above 255 should be understood to refer to Unicode characters.</p>

</li>
<li><p>Be warned that some formatters cannot reliably render characters outside 32-126; and many are able to handle 32-126 and 160-255, but nothing above 255.</p>

</li>
<li><p>Besides the well-known &quot;E&lt;lt&gt;&quot; and &quot;E&lt;gt&gt;&quot; codes for less-than and greater-than, Pod parsers must understand &quot;E&lt;sol&gt;&quot; for &quot;/&quot; (solidus, slash), and &quot;E&lt;verbar&gt;&quot; for &quot;|&quot; (vertical bar, pipe). Pod parsers should also understand &quot;E&lt;lchevron&gt;&quot; and &quot;E&lt;rchevron&gt;&quot; as legacy codes for characters 171 and 187, i.e., &quot;left-pointing double angle quotation mark&quot; = &quot;left pointing guillemet&quot; and &quot;right-pointing double angle quotation mark&quot; = &quot;right pointing guillemet&quot;. (These look like little &quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot;, and they are now preferably expressed with the HTML/XHTML codes &quot;E&lt;laquo&gt;&quot; and &quot;E&lt;raquo&gt;&quot;.)</p>

</li>
<li><p>Pod parsers should understand all &quot;E&lt;html&gt;&quot; codes as defined in the entity declarations in the most recent XHTML specification at <code>www.W3.org</code>. Pod parsers must understand at least the entities that define characters in the range 160-255 (Latin-1). Pod parsers, when faced with some unknown &quot;E&lt;<i>identifier</i>&gt;&quot; code, shouldn&#39;t simply replace it with nullstring (by default, at least), but may pass it through as a string consisting of the literal characters E, less-than, <i>identifier</i>, greater-than. Or Pod parsers may offer the alternative option of processing such unknown &quot;E&lt;<i>identifier</i>&gt;&quot; codes by firing an event especially for such codes, or by adding a special node-type to the in-memory document tree. Such &quot;E&lt;<i>identifier</i>&gt;&quot; may have special meaning to some processors, or some processors may choose to add them to a special error report.</p>

</li>
<li><p>Pod parsers must also support the XHTML codes &quot;E&lt;quot&gt;&quot; for character 34 (doublequote, &quot;), &quot;E&lt;amp&gt;&quot; for character 38 (ampersand, &amp;), and &quot;E&lt;apos&gt;&quot; for character 39 (apostrophe, &#39;).</p>

</li>
<li><p>Note that in all cases of &quot;E&lt;whatever&gt;&quot;, <i>whatever</i> (whether an htmlname, or a number in any base) must consist only of alphanumeric characters -- that is, <i>whatever</i> must match <code>m/\A\w+\z/</code>. So <span style="white-space: nowrap;">&quot;E&lt; 0 1 2 3 &gt;&quot;</span> is invalid, because it contains spaces, which aren&#39;t alphanumeric characters. This presumably does not <i>need</i> special treatment by a Pod processor; <span style="white-space: nowrap;">&quot; 0 1 2 3 &quot;</span> doesn&#39;t look like a number in any base, so it would presumably be looked up in the table of HTML-like names. Since there isn&#39;t (and cannot be) an HTML-like entity called <span style="white-space: nowrap;">&quot; 0 1 2 3 &quot;</span>, this will be treated as an error. However, Pod processors may treat <span style="white-space: nowrap;">&quot;E&lt; 0 1 2 3 &gt;&quot;</span> or &quot;E&lt;e-acute&gt;&quot; as <i>syntactically</i> invalid, potentially earning a different error message than the error message (or warning, or event) generated by a merely unknown (but theoretically valid) htmlname, as in &quot;E&lt;qacute&gt;&quot; [sic]. However, Pod parsers are not required to make this distinction.</p>

</li>
<li><p>Note that E&lt;number&gt; <i>must not</i> be interpreted as simply &quot;codepoint <i>number</i> in the current/native character set&quot;. It always means only &quot;the character represented by codepoint <i>number</i> in Unicode.&quot; (This is identical to the semantics of &amp;#<i>number</i>; in XML.)</p>

<p>This will likely require many formatters to have tables mapping from treatable Unicode codepoints (such as the &quot;\xE9&quot; for the e-acute character) to the escape sequences or codes necessary for conveying such sequences in the target output format. A converter to *roff would, for example know that &quot;\xE9&quot; (whether conveyed literally, or via a E&lt;...&gt; sequence) is to be conveyed as &quot;e\\*&#39;&quot;. Similarly, a program rendering Pod in a Mac OS application window, would presumably need to know that &quot;\xE9&quot; maps to codepoint 142 in MacRoman encoding that (at time of writing) is native for Mac OS. Such Unicode2whatever mappings are presumably already widely available for common output formats. (Such mappings may be incomplete! Implementers are not expected to bend over backwards in an attempt to render Cherokee syllabics, Etruscan runes, Byzantine musical symbols, or any of the other weird things that Unicode can encode.) And if a Pod document uses a character not found in such a mapping, the formatter should consider it an unrenderable character.</p>

</li>
<li><p>If, surprisingly, the implementor of a Pod formatter can&#39;t find a satisfactory pre-existing table mapping from Unicode characters to escapes in the target format (e.g., a decent table of Unicode characters to *roff escapes), it will be necessary to build such a table. If you are in this circumstance, you should begin with the characters in the range 0x00A0 - 0x00FF, which is mostly the heavily used accented characters. Then proceed (as patience permits and fastidiousness compels) through the characters that the (X)HTML standards groups judged important enough to merit mnemonics for. These are declared in the (X)HTML specifications at the www.W3.org site. At time of writing (September 2001), the most recent entity declaration files are:</p>

<pre><code>  http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent
  http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent
  http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent</code></pre>

<p>Then you can progress through any remaining notable Unicode characters in the range 0x2000-0x204D (consult the character tables at www.unicode.org), and whatever else strikes your fancy. For example, in <i>xhtml-symbol.ent</i>, there is the entry:</p>

<pre><code>  &lt;!ENTITY infin    &quot;&amp;#8734;&quot;&gt; &lt;!-- infinity, U+221E ISOtech --&gt;</code></pre>

<p>While the mapping &quot;infin&quot; to the character &quot;\x{221E}&quot; will (hopefully) have been already handled by the Pod parser, the presence of the character in this file means that it&#39;s reasonably important enough to include in a formatter&#39;s table that maps from notable Unicode characters to the codes necessary for rendering them. So for a Unicode-to-*roff mapping, for example, this would merit the entry:</p>

<pre><code>  &quot;\x{221E}&quot; =&gt; &#39;\(in&#39;,</code></pre>

<p>It is eagerly hoped that in the future, increasing numbers of formats (and formatters) will support Unicode characters directly (as (X)HTML does with <code>&amp;infin;</code>, <code>&amp;#8734;</code>, or <code>&amp;#x221E;</code>), reducing the need for idiosyncratic mappings of Unicode-to-<i>my_escapes</i>.</p>

</li>
<li><p>It is up to individual Pod formatter to display good judgement when confronted with an unrenderable character (which is distinct from an unknown E&lt;thing&gt; sequence that the parser couldn&#39;t resolve to anything, renderable or not). It is good practice to map Latin letters with diacritics (like &quot;E&lt;eacute&gt;&quot;/&quot;E&lt;233&gt;&quot;) to the corresponding unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;), but clearly this is often not feasible, and an unrenderable character may be represented as &quot;?&quot;, or the like. In attempting a sane fallback (as from E&lt;233&gt; to &quot;e&quot;), Pod formatters may use the %Latin1Code_to_fallback table in <a href="https://metacpan.org/pod/Pod::Escapes" rel="external">Pod::Escapes</a>, or <a href="https://metacpan.org/pod/Text::Unidecode" rel="external">Text::Unidecode</a>, if available.</p>

<p>For example, this Pod text:</p>

<pre><code>  magic is enabled if you set C&lt;$Currency&gt; to &#39;E&lt;euro&gt;&#39;.</code></pre>

<p>may be rendered as: &quot;magic is enabled if you set <code>$Currency</code> to &#39;<i>?</i>&#39;&quot; or as &quot;magic is enabled if you set <code>$Currency</code> to &#39;<b>[euro]</b>&#39;&quot;, or as &quot;magic is enabled if you set <code>$Currency</code> to &#39;[x20AC]&#39;, etc.</p>

<p>A Pod formatter may also note, in a comment or warning, a list of what unrenderable characters were encountered.</p>

</li>
<li><p>E&lt;...&gt; may freely appear in any formatting code (other than in another E&lt;...&gt; or in an Z&lt;&gt;). That is, &quot;X&lt;The E&lt;euro&gt;1,000,000 Solution&gt;&quot; is valid, as is &quot;L&lt;The E&lt;euro&gt;1,000,000 Solution|Million::Euros&gt;&quot;.</p>

</li>
<li><p>Some Pod formatters output to formats that implement non-breaking spaces as an individual character (which I&#39;ll call &quot;NBSP&quot;), and others output to formats that implement non-breaking spaces just as spaces wrapped in a &quot;don&#39;t break this across lines&quot; code. Note that at the level of Pod, both sorts of codes can occur: Pod can contain a NBSP character (whether as a literal, or as a &quot;E&lt;160&gt;&quot; or &quot;E&lt;nbsp&gt;&quot; code); and Pod can contain &quot;S&lt;foo I&lt;bar&gt; baz&gt;&quot; codes, where &quot;mere spaces&quot; (character 32) in such codes are taken to represent non-breaking spaces. Pod parsers should consider supporting the optional parsing of &quot;S&lt;foo I&lt;bar&gt; baz&gt;&quot; as if it were &quot;foo<i>NBSP</i>I&lt;bar&gt;<i>NBSP</i>baz&quot;, and, going the other way, the optional parsing of groups of words joined by NBSP&#39;s as if each group were in a S&lt;...&gt; code, so that formatters may use the representation that maps best to what the output format demands.</p>

</li>
<li><p>Some processors may find that the <code>S&lt;...&gt;</code> code is easiest to implement by replacing each space in the parse tree under the content of the S, with an NBSP. But note: the replacement should apply <i>not</i> to spaces in <i>all</i> text, but <i>only</i> to spaces in <i>printable</i> text. (This distinction may or may not be evident in the particular tree/event model implemented by the Pod parser.) For example, consider this unusual case:</p>

<pre><code>   S&lt;L&lt;/Autoloaded Functions&gt;&gt;</code></pre>

<p>This means that the space in the middle of the visible link text must not be broken across lines. In other words, it&#39;s the same as this:</p>

<pre><code>   L&lt;&quot;AutoloadedE&lt;160&gt;Functions&quot;/Autoloaded Functions&gt;</code></pre>

<p>However, a misapplied space-to-NBSP replacement could (wrongly) produce something equivalent to this:</p>

<pre><code>   L&lt;&quot;AutoloadedE&lt;160&gt;Functions&quot;/AutoloadedE&lt;160&gt;Functions&gt;</code></pre>

<p>...which is almost definitely not going to work as a hyperlink (assuming this formatter outputs a format supporting hypertext).</p>

<p>Formatters may choose to just not support the S format code, especially in cases where the output format simply has no NBSP character/code and no code for &quot;don&#39;t break this stuff across lines&quot;.</p>

</li>
<li><p>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. <code>E&lt;173&gt;</code> = <code>E&lt;0xAD&gt;</code> = <code>E&lt;shy&gt;</code>). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</p>

<p>For example:</p>

<pre><code>  sigE&lt;shy&gt;action
  manuE&lt;shy&gt;script
  JarkE&lt;shy&gt;ko HieE&lt;shy&gt;taE&lt;shy&gt;nieE&lt;shy&gt;mi</code></pre>

<p>These signal to a formatter that if it is to hyphenate &quot;sigaction&quot; or &quot;manuscript&quot;, then it should be done as &quot;sig-<i>[linebreak]</i>action&quot; or &quot;manu-<i>[linebreak]</i>script&quot; (and if it doesn&#39;t hyphenate it, then the <code>E&lt;shy&gt;</code> doesn&#39;t show up at all). And if it is to hyphenate &quot;Jarkko&quot; and/or &quot;Hietaniemi&quot;, it can do so only at the points where there is a <code>E&lt;shy&gt;</code> code.</p>

<p>In practice, it is anticipated that this character will not be used often, but formatters should either support it, or delete it.</p>

</li>
<li><p>If you think that you want to add a new command to Pod (like, say, a &quot;=biblio&quot; command), consider whether you could get the same effect with a for or begin/end sequence: &quot;=for biblio ...&quot; or &quot;=begin biblio&quot; ... &quot;=end biblio&quot;. Pod processors that don&#39;t understand &quot;=for biblio&quot;, etc, will simply ignore it, whereas they may complain loudly if they see &quot;=biblio&quot;.</p>

</li>
<li><p>Throughout this document, &quot;Pod&quot; has been the preferred spelling for the name of the documentation format. One may also use &quot;POD&quot; or &quot;pod&quot;. For the documentation that is (typically) in the Pod format, you may use &quot;pod&quot;, or &quot;Pod&quot;, or &quot;POD&quot;. Understanding these distinctions is useful; but obsessing over how to spell them, usually is not.</p>

</li>
</ul>

<h1 id="About-L...-Codes">About L&lt;...&gt; Codes</h1>

<p>As you can tell from a glance at <a href="/perldoc/perlpod/">perlpod</a>, the L&lt;...&gt; code is the most complex of the Pod formatting codes. The points below will hopefully clarify what it means and how processors should deal with it.</p>

<ul>

<li><p>In parsing an L&lt;...&gt; code, Pod parsers must distinguish at least four attributes:</p>

<dl>

<dt>First:</dt>
<dd>

<p>The link-text. If there is none, this must be <code>undef</code>. (E.g., in &quot;L&lt;Perl Functions|perlfunc&gt;&quot;, the link-text is &quot;Perl Functions&quot;. In &quot;L&lt;Time::HiRes&gt;&quot; and even &quot;L&lt;|Time::HiRes&gt;&quot;, there is no link text. Note that link text may contain formatting.)</p>

</dd>
<dt>Second:</dt>
<dd>

<p>The possibly inferred link-text; i.e., if there was no real link text, then this is the text that we&#39;ll infer in its place. (E.g., for &quot;L&lt;Getopt::Std&gt;&quot;, the inferred link text is &quot;Getopt::Std&quot;.)</p>

</dd>
<dt>Third:</dt>
<dd>

<p>The name or URL, or <code>undef</code> if none. (E.g., in &quot;L&lt;Perl Functions|perlfunc&gt;&quot;, the name (also sometimes called the page) is &quot;perlfunc&quot;. In &quot;L&lt;/CAVEATS&gt;&quot;, the name is <code>undef</code>.)</p>

</dd>
<dt>Fourth:</dt>
<dd>

<p>The section (AKA &quot;item&quot; in older perlpods), or <code>undef</code> if none. E.g., in &quot;L&lt;Getopt::Std/DESCRIPTION&gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that&#39;s introduced by the heading or item whose text is &quot;Foo&quot;.)</p>

</dd>
</dl>

<p>Pod parsers may also note additional attributes including:</p>

<dl>

<dt>Fifth:</dt>
<dd>

<p>A flag for whether item 3 (if present) is a URL (like &quot;http://lists.perl.org&quot; is), in which case there should be no section attribute; a Pod name (like &quot;perldoc&quot; and &quot;Getopt::Std&quot; are); or possibly a man page name (like &quot;crontab(5)&quot; is).</p>

</dd>
<dt>Sixth:</dt>
<dd>

<p>The raw original L&lt;...&gt; content, before text is split on &quot;|&quot;, &quot;/&quot;, etc, and before E&lt;...&gt; codes are expanded.</p>

</dd>
</dl>

<p>(The above were numbered only for concise reference below. It is not a requirement that these be passed as an actual list or array.)</p>

<p>For example:</p>

<pre><code>  L&lt;Foo::Bar&gt;
    =&gt;  undef,                         # link text
        &quot;Foo::Bar&quot;,                    # possibly inferred link text
        &quot;Foo::Bar&quot;,                    # name
        undef,                         # section
        &#39;pod&#39;,                         # what sort of link
        &quot;Foo::Bar&quot;                     # original content

  L&lt;Perlport&#39;s section on NL&#39;s|perlport/Newlines&gt;
    =&gt;  &quot;Perlport&#39;s section on NL&#39;s&quot;,  # link text
        &quot;Perlport&#39;s section on NL&#39;s&quot;,  # possibly inferred link text
        &quot;perlport&quot;,                    # name
        &quot;Newlines&quot;,                    # section
        &#39;pod&#39;,                         # what sort of link
        &quot;Perlport&#39;s section on NL&#39;s|perlport/Newlines&quot;
                                       # original content

  L&lt;perlport/Newlines&gt;
    =&gt;  undef,                         # link text
        &#39;&quot;Newlines&quot; in perlport&#39;,      # possibly inferred link text
        &quot;perlport&quot;,                    # name
        &quot;Newlines&quot;,                    # section
        &#39;pod&#39;,                         # what sort of link
        &quot;perlport/Newlines&quot;            # original content

  L&lt;crontab(5)/&quot;DESCRIPTION&quot;&gt;
    =&gt;  undef,                         # link text
        &#39;&quot;DESCRIPTION&quot; in crontab(5)&#39;, # possibly inferred link text
        &quot;crontab(5)&quot;,                  # name
        &quot;DESCRIPTION&quot;,                 # section
        &#39;man&#39;,                         # what sort of link
        &#39;crontab(5)/&quot;DESCRIPTION&quot;&#39;     # original content

  L&lt;/Object Attributes&gt;
    =&gt;  undef,                         # link text
        &#39;&quot;Object Attributes&quot;&#39;,         # possibly inferred link text
        undef,                         # name
        &quot;Object Attributes&quot;,           # section
        &#39;pod&#39;,                         # what sort of link
        &quot;/Object Attributes&quot;           # original content

  L&lt;http://www.perl.org/&gt;
    =&gt;  undef,                         # link text
        &quot;http://www.perl.org/&quot;,        # possibly inferred link text
        &quot;http://www.perl.org/&quot;,        # name
        undef,                         # section
        &#39;url&#39;,                         # what sort of link
        &quot;http://www.perl.org/&quot;         # original content

  L&lt;Perl.org|http://www.perl.org/&gt;
    =&gt;  &quot;Perl.org&quot;,                    # link text
        &quot;http://www.perl.org/&quot;,        # possibly inferred link text
        &quot;http://www.perl.org/&quot;,        # name
        undef,                         # section
        &#39;url&#39;,                         # what sort of link
        &quot;Perl.org|http://www.perl.org/&quot; # original content</code></pre>

<p>Note that you can distinguish URL-links from anything else by the fact that they match <code>m/\A\w+:[^:\s]\S*\z/</code>. So <code>L&lt;http://www.perl.com&gt;</code> is a URL, but <code>L&lt;HTTP::Response&gt;</code> isn&#39;t.</p>

</li>
<li><p>In case of L&lt;...&gt; codes with no &quot;text|&quot; part in them, older formatters have exhibited great variation in actually displaying the link or cross reference. For example, L&lt;crontab(5)&gt; would render as &quot;the <code>crontab(5)</code> manpage&quot;, or &quot;in the <code>crontab(5)</code> manpage&quot; or just &quot;<code>crontab(5)</code>&quot;.</p>

<p>Pod processors must now treat &quot;text|&quot;-less links as follows:</p>

<pre><code>  L&lt;name&gt;         =&gt;  L&lt;name|name&gt;
  L&lt;/section&gt;     =&gt;  L&lt;&quot;section&quot;|/section&gt;
  L&lt;name/section&gt; =&gt;  L&lt;&quot;section&quot; in name|name/section&gt;</code></pre>

</li>
<li><p>Note that section names might contain markup. I.e., if a section starts with:</p>

<pre><code>  =head2 About the C&lt;-M&gt; Operator</code></pre>

<p>or with:</p>

<pre><code>  =item About the C&lt;-M&gt; Operator</code></pre>

<p>then a link to it would look like this:</p>

<pre><code>  L&lt;somedoc/About the C&lt;-M&gt; Operator&gt;</code></pre>

<p>Formatters may choose to ignore the markup for purposes of resolving the link and use only the renderable characters in the section name, as in:</p>

<pre><code>  &lt;h1&gt;&lt;a name=&quot;About_the_-M_Operator&quot;&gt;About the &lt;code&gt;-M&lt;/code&gt;
  Operator&lt;/h1&gt;

  ...

  &lt;a href=&quot;somedoc#About_the_-M_Operator&quot;&gt;About the &lt;code&gt;-M&lt;/code&gt;
  Operator&quot; in somedoc&lt;/a&gt;</code></pre>

</li>
<li><p>Previous versions of perlpod distinguished <code>L&lt;name/&quot;section&quot;&gt;</code> links from <code>L&lt;name/item&gt;</code> links (and their targets). These have been merged syntactically and semantically in the current specification, and <i>section</i> can refer either to a &quot;=head<i>n</i> Heading Content&quot; command or to a &quot;=item Item Content&quot; command. This specification does not specify what behavior should be in the case of a given document having several things all seeming to produce the same <i>section</i> identifier (e.g., in HTML, several things all producing the same <i>anchorname</i> in &lt;a name=&quot;<i>anchorname</i>&quot;&gt;...&lt;/a&gt; elements). Where Pod processors can control this behavior, they should use the first such anchor. That is, <code>L&lt;Foo/Bar&gt;</code> refers to the <i>first</i> &quot;Bar&quot; section in Foo.</p>

<p>But for some processors/formats this cannot be easily controlled; as with the HTML example, the behavior of multiple ambiguous &lt;a name=&quot;<i>anchorname</i>&quot;&gt;...&lt;/a&gt; is most easily just left up to browsers to decide.</p>

</li>
<li><p>In a <code>L&lt;text|...&gt;</code> code, text may contain formatting codes for formatting or for E&lt;...&gt; escapes, as in:</p>

<pre><code>  L&lt;B&lt;ummE&lt;234&gt;stuff&gt;|...&gt;</code></pre>

<p>For <code>L&lt;...&gt;</code> codes without a &quot;name|&quot; part, only <code>E&lt;...&gt;</code> and <code>Z&lt;&gt;</code> codes may occur. That is, authors should not use &quot;<code>L&lt;B&lt;Foo::Bar&gt;&gt;</code>&quot;.</p>

<p>Note, however, that formatting codes and Z&lt;&gt;&#39;s can occur in any and all parts of an L&lt;...&gt; (i.e., in <i>name</i>, <i>section</i>, <i>text</i>, and <i>url</i>).</p>

<p>Authors must not nest L&lt;...&gt; codes. For example, &quot;L&lt;The L&lt;Foo::Bar&gt; man page&gt;&quot; should be treated as an error.</p>

</li>
<li><p>Note that Pod authors may use formatting codes inside the &quot;text&quot; part of &quot;L&lt;text|name&gt;&quot; (and so on for L&lt;text|/&quot;sec&quot;&gt;).</p>

<p>In other words, this is valid:</p>

<pre><code>  Go read L&lt;the docs on C&lt;$.&gt;|perlvar/&quot;$.&quot;&gt;</code></pre>

<p>Some output formats that do allow rendering &quot;L&lt;...&gt;&quot; codes as hypertext, might not allow the link-text to be formatted; in that case, formatters will have to just ignore that formatting.</p>

</li>
<li><p>At time of writing, <code>L&lt;name&gt;</code> values are of two types: either the name of a Pod page like <code>L&lt;Foo::Bar&gt;</code> (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like <code>L&lt;crontab(5)&gt;</code>. In theory, <code>L&lt;chmod&gt;</code> is ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given <code>L&lt;foo&gt;</code> code.</p>

</li>
<li><p>Previous versions of perlpod allowed for a <code>L&lt;section&gt;</code> syntax (as in <code>L&lt;Object Attributes&gt;</code>), which was not easily distinguishable from <code>L&lt;name&gt;</code> syntax and for <code>L&lt;&quot;section&quot;&gt;</code> which was only slightly less ambiguous. This syntax is no longer in the specification, and has been replaced by the <code>L&lt;/section&gt;</code> syntax (where the slash was formerly optional). Pod parsers should tolerate the <code>L&lt;&quot;section&quot;&gt;</code> syntax, for a while at least. The suggested heuristic for distinguishing <code>L&lt;section&gt;</code> from <code>L&lt;name&gt;</code> is that if it contains any whitespace, it&#39;s a <i>section</i>. Pod processors should warn about this being deprecated syntax.</p>

</li>
</ul>

<h1 id="About-over...-back-Regions">About =over...=back Regions</h1>

<p>&quot;=over&quot;...&quot;=back&quot; regions are used for various kinds of list-like structures. (I use the term &quot;region&quot; here simply as a collective term for everything from the &quot;=over&quot; to the matching &quot;=back&quot;.)</p>

<ul>

<li><p>The non-zero numeric <i>indentlevel</i> in &quot;=over <i>indentlevel</i>&quot; ... &quot;=back&quot; is used for giving the formatter a clue as to how many &quot;spaces&quot; (ems, or roughly equivalent units) it should tab over, although many formatters will have to convert this to an absolute measurement that may not exactly match with the size of spaces (or M&#39;s) in the document&#39;s base font. Other formatters may have to completely ignore the number. The lack of any explicit <i>indentlevel</i> parameter is equivalent to an <i>indentlevel</i> value of 4. Pod processors may complain if <i>indentlevel</i> is present but is not a positive number matching <code>m/\A(\d*\.)?\d+\z/</code>.</p>

</li>
<li><p>Authors of Pod formatters are reminded that &quot;=over&quot; ... &quot;=back&quot; may map to several different constructs in your output format. For example, in converting Pod to (X)HTML, it can map to any of &lt;ul&gt;...&lt;/ul&gt;, &lt;ol&gt;...&lt;/ol&gt;, &lt;dl&gt;...&lt;/dl&gt;, or &lt;blockquote&gt;...&lt;/blockquote&gt;. Similarly, &quot;=item&quot; can map to &lt;li&gt; or &lt;dt&gt;.</p>

</li>
<li><p>Each &quot;=over&quot; ... &quot;=back&quot; region should be one of the following:</p>

<ul>

<li><p>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item *&quot; commands, each followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</p>

<p>(Pod processors must tolerate a bare &quot;=item&quot; as if it were &quot;=item *&quot;.) Whether &quot;*&quot; is rendered as a literal asterisk, an &quot;o&quot;, or as some kind of real bullet character, is left up to the Pod formatter, and may depend on the level of nesting.</p>

</li>
<li><p>An &quot;=over&quot; ... &quot;=back&quot; region containing only <code>m/\A=item\s+\d+\.?\s*\z/</code> paragraphs, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must start at 1 in each section, and must proceed in order and without skipping numbers.</p>

<p>(Pod processors must tolerate lines like &quot;=item 1&quot; as if they were &quot;=item 1.&quot;, with the period.)</p>

</li>
<li><p>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item [text]&quot; commands, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, or &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</p>

<p>The &quot;=item [text]&quot; paragraph should not match <code>m/\A=item\s+\d+\.?\s*\z/</code> or <code>m/\A=item\s+\*\s*\z/</code>, nor should it match just <code>m/\A=item\s*\z/</code>.</p>

</li>
<li><p>An &quot;=over&quot; ... &quot;=back&quot; region containing no &quot;=item&quot; paragraphs at all, and containing only some number of ordinary/verbatim paragraphs, and possibly also some nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions. Such an itemless &quot;=over&quot; ... &quot;=back&quot; region in Pod is equivalent in meaning to a &quot;&lt;blockquote&gt;...&lt;/blockquote&gt;&quot; element in HTML.</p>

</li>
</ul>

<p>Note that with all the above cases, you can determine which type of &quot;=over&quot; ... &quot;=back&quot; you have, by examining the first (non-&quot;=cut&quot;, non-&quot;=pod&quot;) Pod paragraph after the &quot;=over&quot; command.</p>

</li>
<li><p>Pod formatters <i>must</i> tolerate arbitrarily large amounts of text in the &quot;=item <i>text...</i>&quot; paragraph. In practice, most such paragraphs are short, as in:</p>

<pre><code>  =item For cutting off our trade with all parts of the world</code></pre>

<p>But they may be arbitrarily long:</p>

<pre><code>  =item For transporting us beyond seas to be tried for pretended
  offenses

  =item He is at this time transporting large armies of foreign
  mercenaries to complete the works of death, desolation and
  tyranny, already begun with circumstances of cruelty and perfidy
  scarcely paralleled in the most barbarous ages, and totally
  unworthy the head of a civilized nation.</code></pre>

</li>
<li><p>Pod processors should tolerate &quot;=item *&quot; / &quot;=item <i>number</i>&quot; commands with no accompanying paragraph. The middle item is an example:</p>

<pre><code>  =over

  =item 1

  Pick up dry cleaning.

  =item 2

  =item 3

  Stop by the store.  Get Abba Zabas, Stoli, and cheap lawn chairs.

  =back</code></pre>

</li>
<li><p>No &quot;=over&quot; ... &quot;=back&quot; region can contain headings. Processors may treat such a heading as an error.</p>

</li>
<li><p>Note that an &quot;=over&quot; ... &quot;=back&quot; region should have some content. That is, authors should not have an empty region like this:</p>

<pre><code>  =over

  =back</code></pre>

<p>Pod processors seeing such a contentless &quot;=over&quot; ... &quot;=back&quot; region, may ignore it, or may report it as an error.</p>

</li>
<li><p>Processors must tolerate an &quot;=over&quot; list that goes off the end of the document (i.e., which has no matching &quot;=back&quot;), but they may warn about such a list.</p>

</li>
<li><p>Authors of Pod formatters should note that this construct:</p>

<pre><code>  =item Neque

  =item Porro

  =item Quisquam Est

  Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci 
  velit, sed quia non numquam eius modi tempora incidunt ut
  labore et dolore magnam aliquam quaerat voluptatem.

  =item Ut Enim</code></pre>

<p>is semantically ambiguous, in a way that makes formatting decisions a bit difficult. On the one hand, it could be mention of an item &quot;Neque&quot;, mention of another item &quot;Porro&quot;, and mention of another item &quot;Quisquam Est&quot;, with just the last one requiring the explanatory paragraph &quot;Qui dolorem ipsum quia dolor...&quot;; and then an item &quot;Ut Enim&quot;. In that case, you&#39;d want to format it like so:</p>

<pre><code>  Neque

  Porro

  Quisquam Est
    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
    velit, sed quia non numquam eius modi tempora incidunt ut
    labore et dolore magnam aliquam quaerat voluptatem.

  Ut Enim</code></pre>

<p>But it could equally well be a discussion of three (related or equivalent) items, &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;, followed by a paragraph explaining them all, and then a new item &quot;Ut Enim&quot;. In that case, you&#39;d probably want to format it like so:</p>

<pre><code>  Neque
  Porro
  Quisquam Est
    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
    velit, sed quia non numquam eius modi tempora incidunt ut
    labore et dolore magnam aliquam quaerat voluptatem.

  Ut Enim</code></pre>

<p>But (for the foreseeable future), Pod does not provide any way for Pod authors to distinguish which grouping is meant by the above &quot;=item&quot;-cluster structure. So formatters should format it like so:</p>

<pre><code>  Neque

  Porro

  Quisquam Est

    Qui dolorem ipsum quia dolor sit amet, consectetur, adipisci
    velit, sed quia non numquam eius modi tempora incidunt ut
    labore et dolore magnam aliquam quaerat voluptatem.

  Ut Enim</code></pre>

<p>That is, there should be (at least roughly) equal spacing between items as between paragraphs (although that spacing may well be less than the full height of a line of text). This leaves it to the reader to use (con)textual cues to figure out whether the &quot;Qui dolorem ipsum...&quot; paragraph applies to the &quot;Quisquam Est&quot; item or to all three items &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;. While not an ideal situation, this is preferable to providing formatting cues that may be actually contrary to the author&#39;s intent.</p>

</li>
</ul>

<h1 id="About-Data-Paragraphs-and-begin-end-Regions">About Data Paragraphs and &quot;=begin/=end&quot; Regions</h1>

<p>Data paragraphs are typically used for inlining non-Pod data that is to be used (typically passed through) when rendering the document to a specific format:</p>

<pre><code>  =begin rtf

  \par{\pard\qr\sa4500{\i Printed\~\chdate\~\chtime}\par}

  =end rtf</code></pre>

<p>The exact same effect could, incidentally, be achieved with a single &quot;=for&quot; paragraph:</p>

<pre><code>  =for rtf \par{\pard\qr\sa4500{\i Printed\~\chdate\~\chtime}\par}</code></pre>

<p>(Although that is not formally a data paragraph, it has the same meaning as one, and Pod parsers may parse it as one.)</p>

<p>Another example of a data paragraph:</p>

<pre><code>  =begin html

  I like &lt;em&gt;PIE&lt;/em&gt;!

  &lt;hr&gt;Especially pecan pie!

  =end html</code></pre>

<p>If these were ordinary paragraphs, the Pod parser would try to expand the &quot;E&lt;/em&gt;&quot; (in the first paragraph) as a formatting code, just like &quot;E&lt;lt&gt;&quot; or &quot;E&lt;eacute&gt;&quot;. But since this is in a &quot;=begin <i>identifier</i>&quot;...&quot;=end <i>identifier</i>&quot; region <i>and</i> the identifier &quot;html&quot; doesn&#39;t begin have a &quot;:&quot; prefix, the contents of this region are stored as data paragraphs, instead of being processed as ordinary paragraphs (or if they began with a spaces and/or tabs, as verbatim paragraphs).</p>

<p>As a further example: At time of writing, no &quot;biblio&quot; identifier is supported, but suppose some processor were written to recognize it as a way of (say) denoting a bibliographic reference (necessarily containing formatting codes in ordinary paragraphs). The fact that &quot;biblio&quot; paragraphs were meant for ordinary processing would be indicated by prefacing each &quot;biblio&quot; identifier with a colon:</p>

<pre><code>  =begin :biblio

  Wirth, Niklaus.  1976.  I&lt;Algorithms + Data Structures =
  Programs.&gt;  Prentice-Hall, Englewood Cliffs, NJ.

  =end :biblio</code></pre>

<p>This would signal to the parser that paragraphs in this begin...end region are subject to normal handling as ordinary/verbatim paragraphs (while still tagged as meant only for processors that understand the &quot;biblio&quot; identifier). The same effect could be had with:</p>

<pre><code>  =for :biblio
  Wirth, Niklaus.  1976.  I&lt;Algorithms + Data Structures =
  Programs.&gt;  Prentice-Hall, Englewood Cliffs, NJ.</code></pre>

<p>The &quot;:&quot; on these identifiers means simply &quot;process this stuff normally, even though the result will be for some special target&quot;. I suggest that parser APIs report &quot;biblio&quot; as the target identifier, but also report that it had a &quot;:&quot; prefix. (And similarly, with the above &quot;html&quot;, report &quot;html&quot; as the target identifier, and note the <i>lack</i> of a &quot;:&quot; prefix.)</p>

<p>Note that a &quot;=begin <i>identifier</i>&quot;...&quot;=end <i>identifier</i>&quot; region where <i>identifier</i> begins with a colon, <i>can</i> contain commands. For example:</p>

<pre><code>  =begin :biblio

  Wirth&#39;s classic is available in several editions, including:

  =for comment
   hm, check abebooks.com for how much used copies cost.

  =over

  =item

  Wirth, Niklaus.  1975.  I&lt;Algorithmen und Datenstrukturen.&gt;
  Teubner, Stuttgart.  [Yes, it&#39;s in German.]

  =item

  Wirth, Niklaus.  1976.  I&lt;Algorithms + Data Structures =
  Programs.&gt;  Prentice-Hall, Englewood Cliffs, NJ.

  =back

  =end :biblio</code></pre>

<p>Note, however, a &quot;=begin <i>identifier</i>&quot;...&quot;=end <i>identifier</i>&quot; region where <i>identifier</i> does <i>not</i> begin with a colon, should not directly contain &quot;=head1&quot; ... &quot;=head4&quot; commands, nor &quot;=over&quot;, nor &quot;=back&quot;, nor &quot;=item&quot;. For example, this may be considered invalid:</p>

<pre><code>  =begin somedata

  This is a data paragraph.

  =head1 Don&#39;t do this!

  This is a data paragraph too.

  =end somedata</code></pre>

<p>A Pod processor may signal that the above (specifically the &quot;=head1&quot; paragraph) is an error. Note, however, that the following should <i>not</i> be treated as an error:</p>

<pre><code>  =begin somedata

  This is a data paragraph.

  =cut

  # Yup, this isn&#39;t Pod anymore.
  sub excl { (rand() &gt; .5) ? &quot;hoo!&quot; : &quot;hah!&quot; }

  =pod

  This is a data paragraph too.

  =end somedata</code></pre>

<p>And this too is valid:</p>

<pre><code>  =begin someformat

  This is a data paragraph.

    And this is a data paragraph.

  =begin someotherformat

  This is a data paragraph too.

    And this is a data paragraph too.

  =begin :yetanotherformat

  =head2 This is a command paragraph!

  This is an ordinary paragraph!

    And this is a verbatim paragraph!

  =end :yetanotherformat

  =end someotherformat

  Another data paragraph!

  =end someformat</code></pre>

<p>The contents of the above &quot;=begin :yetanotherformat&quot; ... &quot;=end :yetanotherformat&quot; region <i>aren&#39;t</i> data paragraphs, because the immediately containing region&#39;s identifier (&quot;:yetanotherformat&quot;) begins with a colon. In practice, most regions that contain data paragraphs will contain <i>only</i> data paragraphs; however, the above nesting is syntactically valid as Pod, even if it is rare. However, the handlers for some formats, like &quot;html&quot;, will accept only data paragraphs, not nested regions; and they may complain if they see (targeted for them) nested regions, or commands, other than &quot;=end&quot;, &quot;=pod&quot;, and &quot;=cut&quot;.</p>

<p>Also consider this valid structure:</p>

<pre><code>  =begin :biblio

  Wirth&#39;s classic is available in several editions, including:

  =over

  =item

  Wirth, Niklaus.  1975.  I&lt;Algorithmen und Datenstrukturen.&gt;
  Teubner, Stuttgart.  [Yes, it&#39;s in German.]

  =item

  Wirth, Niklaus.  1976.  I&lt;Algorithms + Data Structures =
  Programs.&gt;  Prentice-Hall, Englewood Cliffs, NJ.

  =back

  Buy buy buy!

  =begin html

  &lt;img src=&#39;wirth_spokesmodeling_book.png&#39;&gt;

  &lt;hr&gt;

  =end html

  Now now now!

  =end :biblio</code></pre>

<p>There, the &quot;=begin html&quot;...&quot;=end html&quot; region is nested inside the larger &quot;=begin :biblio&quot;...&quot;=end :biblio&quot; region. Note that the content of the &quot;=begin html&quot;...&quot;=end html&quot; region is data paragraph(s), because the immediately containing region&#39;s identifier (&quot;html&quot;) <i>doesn&#39;t</i> begin with a colon.</p>

<p>Pod parsers, when processing a series of data paragraphs one after another (within a single region), should consider them to be one large data paragraph that happens to contain blank lines. So the content of the above &quot;=begin html&quot;...&quot;=end html&quot; <i>may</i> be stored as two data paragraphs (one consisting of &quot;&lt;img src=&#39;wirth_spokesmodeling_book.png&#39;&gt;\n&quot; and another consisting of &quot;&lt;hr&gt;\n&quot;), but <i>should</i> be stored as a single data paragraph (consisting of &quot;&lt;img src=&#39;wirth_spokesmodeling_book.png&#39;&gt;\n\n&lt;hr&gt;\n&quot;).</p>

<p>Pod processors should tolerate empty &quot;=begin <i>something</i>&quot;...&quot;=end <i>something</i>&quot; regions, empty &quot;=begin :<i>something</i>&quot;...&quot;=end :<i>something</i>&quot; regions, and contentless &quot;=for <i>something</i>&quot; and &quot;=for :<i>something</i>&quot; paragraphs. I.e., these should be tolerated:</p>

<pre><code>  =for html

  =begin html

  =end html

  =begin :biblio

  =end :biblio</code></pre>

<p>Incidentally, note that there&#39;s no easy way to express a data paragraph starting with something that looks like a command. Consider:</p>

<pre><code>  =begin stuff

  =shazbot

  =end stuff</code></pre>

<p>There, &quot;=shazbot&quot; will be parsed as a Pod command &quot;shazbot&quot;, not as a data paragraph &quot;=shazbot\n&quot;. However, you can express a data paragraph consisting of &quot;=shazbot\n&quot; using this code:</p>

<pre><code>  =for stuff =shazbot</code></pre>

<p>The situation where this is necessary, is presumably quite rare.</p>

<p>Note that =end commands must match the currently open =begin command. That is, they must properly nest. For example, this is valid:</p>

<pre><code>  =begin outer

  X

  =begin inner

  Y

  =end inner

  Z

  =end outer</code></pre>

<p>while this is invalid:</p>

<pre><code>  =begin outer

  X

  =begin inner

  Y

  =end outer

  Z

  =end inner</code></pre>

<p>This latter is improper because when the &quot;=end outer&quot; command is seen, the currently open region has the formatname &quot;inner&quot;, not &quot;outer&quot;. (It just happens that &quot;outer&quot; is the format name of a higher-up region.) This is an error. Processors must by default report this as an error, and may halt processing the document containing that error. A corollary of this is that regions cannot &quot;overlap&quot;. That is, the latter block above does not represent a region called &quot;outer&quot; which contains X and Y, overlapping a region called &quot;inner&quot; which contains Y and Z. But because it is invalid (as all apparently overlapping regions would be), it doesn&#39;t represent that, or anything at all.</p>

<p>Similarly, this is invalid:</p>

<pre><code>  =begin thing

  =end hting</code></pre>

<p>This is an error because the region is opened by &quot;thing&quot;, and the &quot;=end&quot; tries to close &quot;hting&quot; [sic].</p>

<p>This is also invalid:</p>

<pre><code>  =begin thing

  =end</code></pre>

<p>This is invalid because every &quot;=end&quot; command must have a formatname parameter.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="/perldoc/perlpod/">perlpod</a>, <a href="/perldoc/perlsyn/#PODs:-Embedded-Documentation">&quot;PODs: Embedded Documentation&quot; in perlsyn</a>, <a href="https://metacpan.org/pod/podchecker" rel="external">podchecker</a></p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Sean M. Burke</p>



                    </main>
                </div>

        </div>
        <footer>
        
        </footer>


    </body>
</html>
